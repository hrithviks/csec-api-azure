# -----------------------------------------------------------------------------
# Pipeline: csec-API-Service - CI/CD
#
# Overview:
# This pipeline automates the CI/CD process for the csec-API-Service. It
# validates application code, builds a secure container image, and deploys it
# across multiple environments (Dev, Test, Prod) following a structured
# promotion model.
#
# Reliability & Rollback Strategy:
# - Database: Uses transactional execution (Atomicity). If the SQL script fails,
#   the database engine automatically rolls back the transaction, preventing
#   partial deployments.
# - Application: Implements a "Stage-Level Rollback" pattern.
#   1. Captures the current stable image tag before deployment.
#   2. If any job in the stage fails, a dedicated Rollback job automatically
#      reverts the App Service to the captured previous image.
#
# -----------------------------------------------------------------------------
#
# Pipeline Stages Breakdown:
#
# 1. Build Stage:
#    Handles Continuous Integration (CI). It runs SAST (Bandit), dependency
#    scanning (Trivy), and linting (Flake8). If successful, it builds the
#    Docker image, scans it for vulnerabilities, and pushes it to GHCR.
#
# 2. Deploy_Dev Stage:
#    Deploys to the Development environment with full rollback capabilities.
#    - Job 1: Capture_State_Dev: Saves the current App Service image tag.
#    - Job 2: Deploy_DB_Dev: Applies schema changes transactionally.
#    - Job 3: Configure_Dev_App: Updates App Service settings securely.
#    - Job 4: Deploy_App_Dev: Deploys the new container image.
#    - Job 5: Post_Deployment_Validation_Dev: Runs health checks.
#    - Job 6: Rollback_Dev_Stage: Reverts the App Service image if any
#      preceding job fails.
#
# 3. Promotion Stages (Test & Prod) & Notifications:
#    - Deploy_Test: Mirrors the Dev process for QA/UAT (currently disabled).
#    - Deploy_Prod: The final production deployment. Protected by approval gates
#      and runs only on 'release/*' branches. Includes the same capture/rollback
#      logic as Dev.
#    - Notifications: Sends success/failure alerts after pipeline completion.
#
# -----------------------------------------------------------------------------

trigger: none
pr: none

# Use the self-hosted agent pool
pool:
  name: "csec-az-devops-agent-pool"

# Defines pipeline-level variables for configuration and parameterization.
# A structured naming convention (e.g., config.*, app.*) is used for clarity.
variables:
  # Sets centrally defined variables for the pipeline
  # CSEC_AZ_SERVICE_CONN - Service connecton for Azure Resource Manager.
  # CSEC_GITHUB_SERVICE_CONN - Service connection for private github registry.
  - group: csec-pipeline-vars

  # Application Configuration
  - name: app.sourceDirectory
    value: "$(System.DefaultWorkingDirectory)/csb-api-app"
  - name: app.image.name
    value: "ghcr.io/hrithviks/csec-api-service"
  - name: app.image.repository # Image name without the registry, for Docker@2 task
    value: "hrithviks/csec-api-service"
  - name: app.image.tag
    value: "$(Build.BuildId)"

# Define container resources used by the pipeline.
# The jobs will run inside this container, which has Terraform and necessary
# build tools (e.g., Flake8, Docker CLI). pre-installed into it.
resources:
  containers:
    - container: csec-build-container
      image: ghcr.io/hrithviks/csec-build-container:latest
      endpoint: "csec-az-github-registry" # Service connection must be hardcoded here
      # Mount the Docker socket from the host agent into the container.
      options: -v /var/run/docker.sock:/var/run/docker.sock

stages:
  # ----------------------------
  # Stage 1: CI - Build and Scan
  # ----------------------------
  - stage: Build
    displayName: "Build and Push Docker Image"
    jobs:
      - job: BuildImage
        displayName: "Build, Tag, and Push to GHCR"
        container: csec-build-container
        steps:
          - checkout: self
          - script: |
              bandit -r . -ll
            displayName: "Run SAST Scan with Bandit"
            workingDirectory: $(app.sourceDirectory)

          - script: |
              trivy fs --severity HIGH,CRITICAL --exit-code 1 .
            displayName: "Scan Dependencies with Trivy"
            workingDirectory: "$(app.sourceDirectory)"

          - script: |
              flake8 .
            displayName: "Run Code Linting with Flake8"
            workingDirectory: $(app.sourceDirectory)

          - task: Docker@2
            displayName: "Login to GHCR"
            inputs:
              command: "login"
              containerRegistry: $(CSEC_GITHUB_SERVICE_CONN)

          - task: Docker@2
            displayName: "Build Docker Image"
            inputs:
              command: "build"
              repository: $(app.image.repository)
              dockerfile: "$(app.sourceDirectory)/Dockerfile"
              buildContext: "$(app.sourceDirectory)"
              tags: |
                local-scan
                $(app.image.tag)

          - script: trivy image --severity HIGH,CRITICAL --exit-code 1 $(app.image.name):local-scan
            displayName: "Scan Local Docker Image with Trivy"

          - task: Docker@2
            displayName: "Push Image to GHCR"
            inputs:
              command: "push"
              repository: $(app.image.repository)
              tags: |
                $(app.image.tag)

          - task: Docker@2
            displayName: "Logout from GHCR"
            condition: always() # Ensures this step runs even if previous steps fail
            inputs:
              command: "logout"
              containerRegistry: $(CSEC_GITHUB_SERVICE_CONN)

  # -----------------------------------
  # Stage 2: CD - Deploy to Development
  # -----------------------------------
  - stage: Deploy_Dev
    displayName: "Deploy to Dev"
    dependsOn: Build
    variables:
      - group: csec-app-dev-vars # Stage-scoped variables for Dev
    jobs:
      # Job 1: Capture current state for potential rollback
      - job: Capture_State_Dev
        displayName: "Capture Current State (Dev)"
        container: csec-build-container
        steps:
          - task: AzureCLI@2
            name: Capture
            displayName: "Capture App Service State"
            inputs:
              azureSubscription: $(CSEC_AZ_SERVICE_CONN)
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                # Capture current container image
                PREV_IMAGE=$(az webapp config container show -n $(APP_NAME) -g $(RESOURCE_GROUP_NAME) --query '[0].image' -o tsv)
                echo "##vso[task.setvariable variable=PREV_IMAGE;isOutput=true]$PREV_IMAGE"

      # Job 2: Deploy Database Schema to Dev
      - job: Deploy_DB_Dev
        displayName: "Deploy Database Schema to Dev"
        dependsOn: Capture_State_Dev
        container: csec-build-container
        steps:
          - checkout: self # Checkout the repo to get backend.sql

          - template: templates/db-deploy.yml # Invoke the reusable template for DB deployment
            parameters:
              displayName: "Deploy Backend Objects to Dev DB"
              azureServiceConnection: $(CSEC_AZ_SERVICE_CONN)
              vaultName: $(KEY_VAULT_NAME)
              dbHost: $(az keyvault secret show --vault-name "$(KEY_VAULT_NAME)" --name "postgres-db-host" --query "value" -o tsv)
              dbName: $(az keyvault secret show --vault-name "$(KEY_VAULT_NAME)" --name "postgres-db-name" --query "value" -o tsv)
              dbUser: "csb_app"
              dbPasswordKey: "postgres-db-csb-app-user-password"
              script: |
                echo "Executing backend.sql on Dev database..."
                psql -v ON_ERROR_STOP=1 -f "$(app.sourceDirectory)/backend.sql"

      # Job 3: Configure App Environment Variables (Dev)
      - job: Configure_Dev_App
        displayName: "Configure App Environment Variables (Dev)"
        dependsOn: Deploy_DB_Dev
        condition: succeeded()
        container: csec-build-container
        steps:
          - checkout: none

          - task: AzureCLI@2
            displayName: "Update App Service Settings"
            inputs:
              azureSubscription: $(CSEC_AZ_SERVICE_CONN)
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                set -e
                echo "Fetching password from Key Vault..."
                POSTGRES_PASSWORD=$(az keyvault secret show --vault-name "$(KEY_VAULT_NAME)" --name "postgres-db-csb-api-user-password" --query "value" -o tsv)

                echo "Updating App Service environment variables..."
                az webapp config appsettings set -g $(RESOURCE_GROUP_NAME) -n $(APP_NAME) --settings "POSTGRES_USER=$(POSTGRES_USER)" "POSTGRES_PASSWORD=${POSTGRES_PASSWORD}"

                echo "App Service settings updated successfully."

      # Job 4: Deploy Application to Dev
      - deployment: Deploy_App_Dev
        displayName: "Deploy App to Dev Environment"
        dependsOn: Configure_Dev_App # Ensure configuration job finishes first
        container: csec-build-container
        environment: "csec-dev" # Targets an Azure DevOps Environment for tracking
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: none

                - template: templates/app-deploy.yml
                  parameters:
                    azureServiceConnection: $(CSEC_AZ_SERVICE_CONN)
                    appName: $(APP_NAME)
                    resourceGroupName: $(RESOURCE_GROUP_NAME)
                    imageName: "$(app.image.name)"
                    imageTag: "$(app.image.tag)"

      # Job 5: Post-Deployment Validation (Dev)
      - job: Post_Deployment_Validation_Dev
        displayName: "Run Post-Deployment Validations (Dev)"
        dependsOn: Deploy_App_Dev # Runs after the app deployment job
        container: csec-build-container
        steps:
          - checkout: none
          - template: templates/app-validate.yml
            parameters:
              azureServiceConnection: $(CSEC_AZ_SERVICE_CONN)
              appName: $(APP_NAME)
              vaultName: $(KEY_VAULT_NAME)
              resourceGroupName: $(RESOURCE_GROUP_NAME)

      # Job 6: Rollback Dev Stage - Runs if any previous job in the stage fails
      - job: Rollback_Dev_Stage
        displayName: "Rollback Dev Stage"
        dependsOn:
          - Capture_State_Dev
          - Deploy_DB_Dev
          - Configure_Dev_App
          - Deploy_App_Dev
          - Post_Deployment_Validation_Dev
        condition: failed()
        container: csec-build-container
        variables:
          PREV_IMAGE: $[ dependencies.Capture_State_Dev.outputs['Capture.PREV_IMAGE'] ]
        steps:
          - checkout: none

          # 1. Revert App Image
          - task: AzureCLI@2
            displayName: "Rollback App Image"
            condition: and(failed(), ne(variables['PREV_IMAGE'], ''))
            inputs:
              azureSubscription: $(CSEC_AZ_SERVICE_CONN)
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                echo "Rolling back App Service image to: $(PREV_IMAGE)"
                az webapp config container set -n $(APP_NAME) -g $(RESOURCE_GROUP_NAME) --docker-custom-image-name "$(PREV_IMAGE)"

  # ----------------------------
  # Stage 3: CD - Deploy to Test
  # ----------------------------
  - stage: Deploy_Test
    displayName: "Deploy to Test"
    dependsOn: Deploy_Dev
    variables:
      - group: csec-app-test-vars # Stage-scoped variables for Test
    # This stage is explicitly disabled. To enable, change to 'succeeded()'.
    condition: false
    jobs:
      # Job 1: Capture State (Test)
      - job: Capture_State_Test
        displayName: "Capture Current State (Test)"
        container: csec-build-container
        steps:
          - task: AzureCLI@2
            name: Capture
            displayName: "Capture App Service State"
            inputs:
              azureSubscription: $(CSEC_AZ_SERVICE_CONN)
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                PREV_IMAGE=$(az webapp config container show -n $(APP_NAME) -g $(RESOURCE_GROUP_NAME) --query '[0].image' -o tsv)
                echo "##vso[task.setvariable variable=PREV_IMAGE;isOutput=true]$PREV_IMAGE"

      # Job 2: Deploy Database Schema to Test
      - job: Deploy_DB_Test
        displayName: "Deploy Database Schema to Test"
        dependsOn: Capture_State_Test
        container: csec-build-container
        steps:
          - checkout: self # Checkout the repo to get backend.sql
          - template: templates/db-deploy.yml
            parameters:
              displayName: "Deploy Backend Objects to Test DB"
              azureServiceConnection: $(CSEC_AZ_SERVICE_CONN)
              vaultName: $(KEY_VAULT_NAME)
              dbHost: $(az keyvault secret show --vault-name "$(KEY_VAULT_NAME)" --name "postgres-db-host" --query "value" -o tsv)
              dbName: $(az keyvault secret show --vault-name "$(KEY_VAULT_NAME)" --name "postgres-db-name" --query "value" -o tsv)
              dbUser: "csb_app"
              dbPasswordKey: "postgres-db-csb-app-user-password"
              script: |
                echo "Executing backend.sql on Test database..."
                psql -v ON_ERROR_STOP=1 -f "$(app.sourceDirectory)/backend.sql"

      # Job 3: Configure App Environment Variables (Test)
      - job: Configure_Test_App
        displayName: "Configure App Environment Variables (Test)"
        dependsOn: Deploy_DB_Test
        container: csec-build-container
        steps:
          - checkout: none
          - task: AzureCLI@2
            displayName: "Update App Service Settings"
            inputs:
              azureSubscription: $(CSEC_AZ_SERVICE_CONN)
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                set -e
                echo "Fetching password from Key Vault..."
                POSTGRES_PASSWORD=$(az keyvault secret show --vault-name "$(KEY_VAULT_NAME)" --name "postgres-db-csb-api-user-password" --query "value" -o tsv)

                echo "Updating App Service environment variables..."
                az webapp config appsettings set -g $(RESOURCE_GROUP_NAME) -n $(APP_NAME) --settings "POSTGRES_USER=$(POSTGRES_USER)" "POSTGRES_PASSWORD=${POSTGRES_PASSWORD}"

      # Job 4: Deploy Application to Test
      - deployment: Deploy_App_Test
        displayName: "Deploy App to Test Environment"
        dependsOn: Configure_Test_App # Ensure configuration job finishes first
        container: csec-build-container
        environment: "csec-test" # Targets an Azure DevOps Environment for tracking
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: none
                - template: templates/app-deploy.yml
                  parameters:
                    azureServiceConnection: $(CSEC_AZ_SERVICE_CONN)
                    appName: $(APP_NAME)
                    resourceGroupName: $(RESOURCE_GROUP_NAME)
                    imageName: "$(app.image.name)"
                    imageTag: "$(app.image.tag)"

      # Job 5: Post-Deployment Validation (Test)
      - job: Post_Deployment_Validation_Test
        displayName: "Run Post-Deployment Validations (Test)"
        dependsOn: Deploy_App_Test # Runs after the app deployment job
        container: csec-build-container
        steps:
          - checkout: none
          - template: templates/app-validate.yml
            parameters:
              azureServiceConnection: $(CSEC_AZ_SERVICE_CONN)
              appName: $(APP_NAME)
              vaultName: $(KEY_VAULT_NAME)
              resourceGroupName: $(RESOURCE_GROUP_NAME)

      # Job 6: Rollback Test Stage
      - job: Rollback_Test_Stage
        displayName: "Rollback Test Stage"
        dependsOn:
          - Capture_State_Test
          - Deploy_DB_Test
          - Configure_Test_App
          - Deploy_App_Test
          - Post_Deployment_Validation_Test
        condition: failed()
        container: csec-build-container
        variables:
          PREV_IMAGE: $[ dependencies.Capture_State_Test.outputs['Capture.PREV_IMAGE'] ]
        steps:
          - checkout: none
          - task: AzureCLI@2
            displayName: "Rollback App Image"
            condition: and(failed(), ne(variables['PREV_IMAGE'], ''))
            inputs:
              azureSubscription: $(CSEC_AZ_SERVICE_CONN)
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                echo "Rolling back App Service image to: $(PREV_IMAGE)"
                az webapp config container set -n $(APP_NAME) -g $(RESOURCE_GROUP_NAME) --docker-custom-image-name "$(PREV_IMAGE)"

  # ----------------------------------
  # Stage 4: CD - Deploy to Production
  # ----------------------------------
  - stage: Deploy_Prod
    displayName: "Deploy to Prod"
    dependsOn: Deploy_Test
    variables:
      - group: csec-app-prod-vars # Stage-scoped variables for Prod
    # This stage runs only if the previous stages succeeded AND the build was
    # triggered for a branch that starts with 'release/'. This provides a
    # gate to ensure only release-ready code is deployed to Production.
    condition: and(succeeded(), startsWith(variables['Build.SourceBranch'], 'refs/heads/release/'))
    jobs:
      # Job 1: Capture State (Prod)
      - job: Capture_State_Prod
        displayName: "Capture Current State (Prod)"
        container: csec-build-container
        steps:
          - task: AzureCLI@2
            name: Capture
            displayName: "Capture App Service State"
            inputs:
              azureSubscription: $(CSEC_AZ_SERVICE_CONN)
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                PREV_IMAGE=$(az webapp config container show -n $(APP_NAME) -g $(RESOURCE_GROUP_NAME) --query '[0].image' -o tsv)
                echo "##vso[task.setvariable variable=PREV_IMAGE;isOutput=true]$PREV_IMAGE"

      # Job 2: Deploy Database Schema to Prod
      - job: Deploy_DB_Prod
        displayName: "Deploy Database Schema to Prod"
        dependsOn: Capture_State_Prod
        container: csec-build-container
        steps:
          - checkout: self
          - template: templates/db-deploy.yml
            parameters:
              displayName: "Deploy Backend Objects to Prod DB"
              azureServiceConnection: $(CSEC_AZ_SERVICE_CONN)
              vaultName: $(KEY_VAULT_NAME)
              dbHost: $(az keyvault secret show --vault-name "$(KEY_VAULT_NAME)" --name "postgres-db-host" --query "value" -o tsv)
              dbName: $(az keyvault secret show --vault-name "$(KEY_VAULT_NAME)" --name "postgres-db-name" --query "value" -o tsv)
              dbUser: "csb_app"
              dbPasswordKey: "postgres-db-csb-app-user-password"
              script: |
                echo "Executing backend.sql on Prod database..."
                psql -v ON_ERROR_STOP=1 -f "$(app.sourceDirectory)/backend.sql"

      # Job 3: Configure App Environment Variables (Prod)
      - job: Configure_Prod_App
        displayName: "Configure App Environment Variables (Prod)"
        dependsOn: Deploy_DB_Prod
        container: csec-build-container
        steps:
          - checkout: none
          - task: AzureCLI@2
            displayName: "Update App Service Settings"
            inputs:
              azureSubscription: $(CSEC_AZ_SERVICE_CONN)
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                set -e
                POSTGRES_PASSWORD=$(az keyvault secret show --vault-name "$(KEY_VAULT_NAME)" --name "postgres-db-csb-api-user-password" --query "value" -o tsv)
                az webapp config appsettings set -g $(RESOURCE_GROUP_NAME) -n $(APP_NAME) --settings "POSTGRES_USER=$(POSTGRES_USER)" "POSTGRES_PASSWORD=${POSTGRES_PASSWORD}"

      # Job 4: Deploy Application to Prod
      - deployment: Deploy_App_Prod
        displayName: "Deploy App to Prod Environment"
        dependsOn: Configure_Prod_App
        container: csec-build-container
        environment: "csec-prod" # Targets the Prod environment with approval gates
        # ----------------------------------------------------------------------------
        # NOTE ON DEPLOYMENT OPTIONS:
        #
        # 1. Current Limitations:
        #    The current deployment strategy updates the production instance directly.
        #    This can lead to "cold starts" and potential downtime during the
        #    container pull and restart process. It is not ideal for mission-critical
        #    applications requiring zero downtime.
        #
        # 2. Recommended Strategy: Deployment Slots (Blue/Green)
        #    For zero-downtime deployments, Azure App Service Deployment Slots should
        #    be utilized.
        #    - Deploy to a 'Staging' slot first.
        #    - Validate health on the staging slot.
        #    - Perform a 'Swap' operation to instantly promote Staging to Production.
        #    - Rollback involves simply swapping back.
        #    *Note: This requires a Standard (S1) or Premium (P1v2) App Service Plan.*
        #
        # 3. Infrastructure Isolation:
        #    For true isolation, the Production environment should reside in a
        #    completely separate Resource Group (Easily scalable using Terraform)
        #    with a dedicate App Service Plan (e.g., Premium tier). This prevents
        #    resource contention between Staging/Dev slots and live Production traffic.
        # ----------------------------------------------------------------------------
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: none
                - template: templates/app-deploy.yml
                  parameters:
                    azureServiceConnection: $(CSEC_AZ_SERVICE_CONN)
                    appName: $(APP_NAME)
                    resourceGroupName: $(RESOURCE_GROUP_NAME)
                    imageName: "$(app.image.name)"
                    imageTag: "$(app.image.tag)"

      # Job 5: Post-Deployment Validation (Prod)
      - job: Post_Deployment_Validation_Prod
        displayName: "Run Post-Deployment Validations (Prod)"
        dependsOn: Deploy_App_Prod
        container: csec-build-container
        steps:
          - checkout: none
          - template: templates/app-validate.yml
            parameters:
              azureServiceConnection: $(CSEC_AZ_SERVICE_CONN)
              appName: $(APP_NAME)
              vaultName: $(KEY_VAULT_NAME)
              resourceGroupName: $(RESOURCE_GROUP_NAME)

      # Job 6: Rollback Prod Stage
      - job: Rollback_Prod_Stage
        displayName: "Rollback Prod Stage"
        dependsOn:
          - Capture_State_Prod
          - Deploy_DB_Prod
          - Configure_Prod_App
          - Deploy_App_Prod
          - Post_Deployment_Validation_Prod
        condition: failed()
        container: csec-build-container
        variables:
          PREV_IMAGE: $[ dependencies.Capture_State_Prod.outputs['Capture.PREV_IMAGE'] ]
        steps:
          - checkout: none
          - task: AzureCLI@2
            displayName: "Rollback App Image"
            condition: and(failed(), ne(variables['PREV_IMAGE'], ''))
            inputs:
              azureSubscription: $(CSEC_AZ_SERVICE_CONN)
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                echo "Rolling back App Service image to: $(PREV_IMAGE)"
                az webapp config container set -n $(APP_NAME) -g $(RESOURCE_GROUP_NAME) --docker-custom-image-name "$(PREV_IMAGE)"

  # -----------------------------------------
  # Stage 5: Post-Deployment Processing Stage
  # -----------------------------------------
  - stage: Post_Deployment_Processing
    displayName: "Post-Deployment Notifications"
    dependsOn: Deploy_Prod
    condition: false # Explicitly disable this stage
    jobs:
      - job: Send_Success_Notification
        displayName: "Send Success Notification"
        condition: succeeded()
        container: csec-build-container
        steps:
          - checkout: none
          - script: |
              echo "##[section]Pipeline Succeeded"
              echo "Application deployment completed successfully."
              echo "Sending success notification..."
              echo "This is a placeholder."
            displayName: "Send Success Email (Placeholder)"

      - job: Send_Failure_Notification
        displayName: "Send Failure Notification"
        condition: failed()
        container: csec-build-container
        steps:
          - checkout: none
          - script: |
              echo "##[warning]Pipeline Failed"
              echo "One or more deployment stages failed. Please review the logs."
              echo "Sending failure notification..."
              echo "This is a placeholder."
            displayName: "Send Failure Email (Placeholder)"
